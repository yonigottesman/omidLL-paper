

We now describe \sys, a scalable low-latency TPS on top of HBase. 
\sys\ is an evolution of Omid, redesigned to reduce latency by distributing the commit entries.
We begin in Section~\ref{ssec:schema} with some background on the modus operandi of existing TPSs that support SI, including Omid. 
We will see that, while many TPSs follow a similar schema,  there are different design choices to be made in popluating the schema. 
We discuss the design choice of \sys\ in Section~\ref{ssec:ll-txns}. 

\subsection{Schema of TPS operation}
\label{ssec:schema}


In many TPSs, transaction processing follows the general schema outlined in Algorithm~\ref{alg:schema}, 
while systems vary in their implementations of each of the steps. 
For example, whereas most systems rely on a centralized service for timestamp allocation~\cite{OmidICDE2014,omid-fast,tephra,Percolator2010}, this is not essential~\cite{cockroach}; similarly, validation (conflict detection) can use a centralized service~\cite{OmidICDE2014,omid-fast,tephra}, per-transaction entries in a global table~\cite{cockroach}, or distributed locking and validation~\cite{Percolator2010}. 
Different ways to implement this schema are  discussed in Section~\ref{sec:context}.
We now overview the phases a transaction goes through, focusing on Omid's approach.

\begin{algorithm}[tb]
\begin{algorithmic}[1]
\Procedure{begin}{}
\State obtain read timestamp $ts_r$ 
\EndProcedure
\Statex

\Procedure{read}{key} \Comment transactional read
\If{hasWriteIntent(key)}
	\State resolve, possibly  aborting transactions \label{l:resolve}
\EndIf
\State return highest version   $\le ts_r$ of key
\EndProcedure
\Statex

\Procedure{write}{key, value} \Comment transactional write
\State optionally check for conflicts and abort if found 
\State indicate write intent for key with value and $ts_r$
\State add key to local write-set
\EndProcedure
\Statex

\Procedure{commit}{write-set}
\State obtain commit timestamp $ts_c$
\Statex \Comment check for write-write conflicts  \label{l:validate}
\If{validate(write-set, $ts_c$)}  
	\Statex \Comment commit all write intents with version $ts_c$
	\State atomically and persistently indicate commit   \label{l:commit}
\Else
	\State abort	
\EndIf
\State clean-up write intents and other meta-data
\EndProcedure
\end{algorithmic}
\caption{TPS operation schema.} 
\label{alg:schema}
\end{algorithm} 


\paragraph{Begin.} 
  When a transaction begins, it obtains a read timestamp (version) $ts_r$ for reading its consistent snapshot, and unique transaction id.
  The two can be combined (i.e., $ts_r$ can serve as the  transaction id, provided that it is unique).
  In most cases, this is done using a centralized entity (sometimes called timestamp oracle~\cite{Percolator2010,OmidICDE2014}
   or transaction manager~\cite{omid-blog}). 
%  In CockroachDB, the timestamp is based on a local clock that is ``close to'' real-time and preserves causality 
 % across regions, and unique transaction ids are used to break ties in case timestamps (from different regions) are identical. 

  \paragraph{Transactional reads and writes.} 
  %: Collect reads and indicate write intents -- 
 In the course of a transaction, reads  obtain a consistent snapshot,
 %\emph{collect} values for their transaction's snapshot, 
 while write operations indicate their \emph{intent} to write. 
 %\Idit{We said that it was possible to do write intents at commit time rather than encounter time, 
 %but do we have any example of a system that does it? I think not, hence removed this.
 % Only warp does but it's different as it's not SI, not multi-versioned.}
  	 	\begin{itemize}
  		\item  \emph{A read operation} obtains the value of a single object atomically. 
  		Only versions committed with timestamps  smaller or equal to the transaction's $ts_1$ are read. 
 		Different  policies are used for resolving pending write intents. For example, Omid 1 resolves them 
 		using data on all past commits that the client obtains at begin time, whereas CockroachDB and Omid 2 
 		have the read refer to a centralized transaction table (also called commit table). 
		Percolator  waits for the intent to be lifted (by the completion of the writing transactions), and in case the wait times-out, 
		forces this transaction to abort. 
	 	 CockroachDB forces the transaction with the write intent to either commit with a higher version 
  		than its own read timestamp, or abort. Similarly, the solution we implement in \sys\ forces the transaction with the pending write 
  		intent to abort. 
  		\item \emph{Indicating write intents} changes the objects' write intent columns
  		to indicate a transaction attempting to write them is under way. The value the
  		transaction intends to write is added with a new version, typically the transaction's $ts_1$.
% In Omid, this   		version is the transaction's id. 
		Each object is updated atomically by itself. 
		In some solutions writes check for conflicts before declaring their intents~\cite{cockroach}, whereas in others, 
		all conflict detection is deferred to commit time. 
  %This can occur either at encounter time or at commit time, in which case it occurs as the first phase of the commit. 
  	\end{itemize}
  \paragraph{Commit.} 
  When a transaction is ready to commit, it gets a commit timestamp, $ts_w$. 
  In most cases, e.g.,~\cite{Percolator2010,tephra,OmidICDE2014,omid-blog}, 
  this is the GVC value at commit time. 
  Before the transaction can commit, it must check that it does not conflict with any 
  concurrent transactions.  For SI, we need to check for write-write conflicts only. 
  This step checks write intentions as well as version numbers. It may be combined  with the above step using a centralized 
  transaction manager~\cite{OmidICDE2014,tephra,omid-blog}, or may rely a two-phase commit protocol where the written objects are first 
  locked, then validated, and then committed~\cite{Percolator2010}. 
 Alternatively, conflicts may be detected in situ by atomically validating each written object as part of adding a write  intent~\cite{cockroach}.
 
 In case validation succeeds, the transaction is committed 
  in one atomic irrevocable  step. This is achieved by writing to a designated persistent \emph{commit entry}, 
  which can reside in a global table (like the commit table of 
  Omid 2 and the transaction table of CockroachDB) or alongside the first  key written by 
  the transaction (as in Percolator and \sys).  Note that a commit attempt may fail and abort instead. 
 
  Finally, a transaction changes its write intents to
  persistent writes in case of commit, and removes them in case of abort. This
  phase occurs after the transaction is persistently committed or aborted via the commit entry, in
  order to reduce the overhead of future transactions (by sparing them the need to check the commit entry)
  and to garbage collect   obsolete information. 
  
  \remove{Note that whenever a transaction encounters a write
  indication in the collect phase it must access the commit entry in order to
  check the transaction's commit status. Once the clean-up phase is over, future
  transactions no longer incur this overhead for keys updated by the terminated
  transaction.}


 

\subsection{\sys\ design choices}
\label{ssec:ll-txns}

In Section~\ref{sec:context} we outlined the design space of existing TPSs that support SI semantics via the general paradigm outlined in Algorithm~\ref{alg:schema}. 
The design choices made by different existing TPSs as well as by \sys\ are summarized in Table~\ref{table:design-space}.
\Yoni{Does centrelized mean only one entity has access to it, or does it mean the table is not distributed?}
\begin{table}[htb]

\centerline{
\begin{tabular}{|l|cccc|}
\hline
TPS & txn  	& \multicolumn{2}{c}{		 validation} & reads\\
	& entry	& 	scheme & time & cause abort	\\
\hline
Omid, Tephra 	& {\bf R}   & {\bf C} & commit & no\\
Percolator 		& {\bf D}   & {\bf D} & commit & yes \\
Omid 2 			& {\bf C}  	& {\bf C} & commit & no\\
CockroachDB 		& {\bf C}  	& {\bf D} & write & yes\\
\sys				& {\bf D} 	& {\bf C} & commit & \Yoni{yes?!}\\
%\hline
\end{tabular}
}
\caption{Design choices  in TPSs. {\bf C} -- centralized,  {\bf D} -- distributed, {\bf R} -- replicated.}
\label{table:design-space}
\end{table}

All considered TPSs store per-transaction entries, which are the source of truth regarding the transaction status (pending, committed, or aborted). 
This entry is updated in line~\ref{l:commit} of Algorithm~\ref{alg:schema}, and are checked in order to resolve write intents in line~\ref{l:resolve}.
Omid 1 and Tephra replicate this information among all active clients, which consumes high bandwidth and does not scale. Omid 2 and 
CockroachDB use dedicated tables. In experiments we ran, we observed that the centralized table is Omid 2's principal scalability bottleneck, and while this bottleneck is mitigated via batching commit table updates, this also increases latency. 
%Omid 2 chose this  option as it was designed primarily for high throughput, with less emphasis on latency. On the other hand, we target our fast path transactions for workloads that require low latency. 
We therefore opt to follow (in this aspect) the design of Percolator, which stores the transaction's entry alongside its first written key and stores pointers to this first key at all other keys written by the transaction. Thus, updates of transaction entries can be performed in parallel by 
independent clients, and such updates are no longer a performance bottleneck. 
We will see below that this modification improves performance \Idit{quantify!}

Percolator also performs conflict detection (line~\ref{l:validate}) in a distributed manner, using a two-phase commit protocol, where all objects are locked during the validation.  Unfortunately, as long as a lock is held, it blocks all transactions attempting to access the locked object. Since clients might stall or 
crash while holding a lock, Percolator supports a recovery procedure that allows blocked transactions to forcefully abort pending ones, 
after a certain timeout. Later works (on Omid and Tephra) have decided to forgo such blocking, and replaced the two-phase commit protocol by 
centralized conflict detection. CockroachDB takes a different approach of performing distributed validation at write time, by replacing writes with atomic validate-and-write operations that can abort either the current transaction or a conflicting one. Since the centralized conflict detection in Omid 2 is extremely scalable, (capable of sustaining orders of magnitude higher throughput than the network), 
\sys\ adopts this mechanism from Omid 2. 

The centralized service, called Transactional Status Oracle (TSO), maintains an in-memory hash table mapping keys to 
commit timestamps ($ts_c$) of transactions that last wrote them. A conflict arises whenever a key in a transaction's write-set has been written 
with a timestamp higher than its $ts_r$. 
In case the conflict detection service crashes, all pending transactions are aborted, and it can be immediately restarted with an empty table, because only conflicts with concurrent transactions need to be checked. 

Whenever a read encounters a write intent, it resolves it (line~\ref{l:resolve}) via the commit entry at the first written key. 
If the commit entry is committed, the written value is taken into account, and if it is aborted, the value is ignored. 
But if the commit entry is neither committed nor aborted, the reading transaction forces the writing transaction to abort by using 
an atomic read-modify-write operation to set its status to aborted. Similar scenarios occur in Percolator and CockroachDB, since 
they use distributed validation. Omid and Tephra, on the other hand, do not need to force such aborts, because they use a single centralized service for timestamp allocation, validation, and writing the commit entry in a way that ensures that  if the read sees a write intent by an uncommitted transaction, that transaction will not commit with an earlier timestamp than the read.
%
The possibility of reads aborting pending transactions means that commit attempts (line~\ref{l:commit}) have to  
check whether the transaction is aborted atomically with writing the commit status.

\remove{

\subsection{Local transactions in \sys}
\label{ssec:fp-impl}
To support local transactions, we implemented the algorithms and APIs described in Section~\ref{sec:alg}. Each Hbase region server maintains an LVC which is updated whenever a transaction accesses it. Omid 2 API was extended to support FP transactions, and the write stage in reglar transactions was modified to use checkAndMutate instead of put. 



\subsection{Background: TPS algorithm schema}



Transaction processing thus follows the general schema outlined in Algorithm~\ref{alg:schema}, 
while systems vary in their implementations of each of the steps. 
For example, whereas most systems rely on a centralized service (requiring remote access) for timestamp allocation~\cite{OmidICDE2014,omid-blog,tephra,Percolator2010}, this is not essential~\cite{cockroach}; similarly, validation (conflict detection) can use a centralized service~\cite{OmidICDE2014,omid-blog,tephra}, per-transaction entries in a global table~\cite{cockroach}, or two-phase commit~\cite{Percolator2010}. 
Different ways to implement this schema are  discussed in Section~\ref{sec:context}.
 
 }
 