
This section outlines the general characteristics of transaction processing systems that can benefit from our 
suggested ``fast-path'' for handling short local transactions. 
We we overview a generic schema for managing global transactions 
(and conflict resultion), which is used in the TPSs we target (Section~\ref{ssec:global-transactions}).
TPSs that adhere to this schema include Percolator~\cite{Percolator2010}, Omid~\cite{OmidICDE2014}, Tephra~\cite{tephra}, and CockroachDB~\cite{cockroach}.

When a transaction begins, it obtains a read timestamp (for its consistent snapshot) and unique transaction id.
In most cases, this is done using a centralized entity (sometimes called timestamp oracle or transaction manager). 
In CockroachDB, the timestamp is based on a local clock that is ``close to'' real-time and preserves causality of access 
across regions. Commit-time conflict detection can use a centralized transaction manager as in Omid~\cite{OmidICDE2014,omid-blog} and Tephra~\cite{tephra}, or rely on a two-phase commit protocol where the written records are first 
locked, then validated, and then committed. 

A read operation retrieves the latest version that does not exceed the transaction's read timestamp. 
Different resolution policies are used for resolving pending write intents. For example, the first version of Omid~\cite{OmidICDE2014}
resolves them using data on past commits that the client obtains at begin time, 
whereas CockroachDB and the new version of Omid~\cite{omid-blog} have the read refer to a centralized transaction table (also called commit table).  Percolator, on the other hand, waits for the transaction that wrote the intent to complete, and when timing out on it, forces it to abort. 
In some solutions writes check for conflicts before declaring their intents~\cite{cockroach}, whereas in others, 
conflict detection is deferred to commit time. 


A TPS's API is offered by a client library, which accesses the data directly in the data store, and 
performs coordination actions to begin, commit, or abort transactions. 

The TPSs we consider all rely on versions for coordination: when a transaction begins it obtains a \emph{tentative version}, which 
it uses (1) to determine what version of each key to read; and (2) as the version of data items it writes.   
In Percolator, Omid, and Tephra, as well as our implementation in this paper, timestamps are provided by a monotonically
increasing \emph{global version  clock (GVC)}. CockroachDB instead provides the beginning transaction with the local clock of
one of the regions (called node therein), which is closely synchronized relative to other regions and furthermore ensures causality.

Transactions indicate their intention to write to an object; this is done using
a dedicated column (part of the value in our data model), which keeps logical
(application-level) locks in some implementations (Percolator) and tentative
updates in others (e.g., the new version of Omid~\cite{omid-blog}, and CockroachDB). 
While write intentions differ across implementations, we assume that the following generic boolean function is  provided:
\begin{description}
\item[\code{hasWriteIntent(key, version)}] returns true if the specified version of key has a write intent indication; if version is not provided, the 
latest version associated with key is checked.
\end{description}

Note: in certain implementations (like the virtual lock per-key used in Percolator), the write-intent of all versions associated 
with the same key is the same, whereas in other cases (like Omid, which uses tentative versions), a
new version may have a write intent while an older one does not.

A transaction goes through the following phases:
\begin{enumerate}
  \item{Begin} -- A transaction obtains a tentative version number when it starts. 
  It also obtains a unique transaction id.
  The two can be combined (i.e., the tentative version can be the same as the  transaction id).
  \item{Collect reads and indicate write intention} -- (either jointly or  collect first and then write).
  	\begin{itemize}
  		\item  \emph{Collect} means reading object values  and versions; each object atomically. 
  		Only versions committed with timestamps  smaller or equal to the transaction's tentative version are read. 
  		Encountered write indications by uncommitted transactions are dealt with differently in different systems, e.g., Percolator 
  		waits for the indication to be lifted, Omid ignores uncommitted versions and checks for conflicts this may induce at
  		commit time, and CockroachDB forces the transaction with the write indication to either commit with a higher version 
  		than its own tentative version, or abort. Similarly, the solution we implement in this paper forces the transaction with the write 
  		indication to abort. 
  		Collect occurs during the transaction (encounter time).
  		\item \emph{Indicating write intention} changes the objects' write intention columns
  		to indicate a transaction attempting to write them is under way. The value the
  		transaction intends to write is added with a new version. In Omid, this
  		version is the transaction's id. Each object is updated atomically. This can
  		occur either at encounter time or at commit time, in which case it occurs as the first phase of the commit. 
  	\end{itemize}
  \item{Validation/conflict detection} -- Before a transaction can commit, it must check that it does not conflict with any 
  concurrent transactions.  For SI, we need to check for write-write conflicts only. 
  This step checks write intentions as well as version numbers. It is performed differently in different systems.
  \item{Commit} --  In case validation succeeds, the transaction may be committed 
  in one atomic step to a designated \emph{commit entry}, which can reside in a global table (like the Commit Table of 
  the new version of Omid and the Transaction Table of CockroachDB) or alongside the first  key written by 
  the transaction (as in Percolator and the implementation in this paper).  Note that a commit attempt may
  fail and abort instead. 
  \item{Clean-up} -- changes the write intentions of the transaction to
  persistent writes in case of commit, and removes them in case of abort. This
  phase occurs after the transaction is persistently committed or aborted, in
  order to reduce the overhead of future transactions and garbage collect
  obsolete information. 
  \remove{Note that whenever a transaction encounters a write
  indication in the collect phase it must access the commit entry in order to
  check the transaction's commit status. Once the clean-up phase is over, future
  transactions no longer incur this overhead for keys updated by the terminated
  transaction.}
\end{enumerate}

 