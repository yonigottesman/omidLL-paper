
This section outlines the general characteristics of transaction processing systems that can benefit from our 
suggested fast-path for handling short local transactions; these TPSs follow the generic schema of Algorithm~\ref{alg:schema} above. 
We illustrate how 
Percolator~\cite{Percolator2010}, Omid 1~\cite{OmidICDE2014}, Omid 2~\cite{omid-blog}, 
Tephra~\cite{tephra}, and CockroachDB~\cite{cockroach} adhere to this schema.

A TPS's API is offered by a client library, which accesses the data directly in the data store, and 
performs coordination actions to begin, commit, or abort transactions. 

The TPSs we consider all rely on timestamps for coordination: when a transaction begins it obtains a \emph{tentative timestamp} $ts_1$, 
which it uses (1) to determine what version of each key to read; possibly (2) as a tetntative version for data items it writes; and possibly (3) as a unique transaction id.   
In Percolator, Omid, Tephra, and \sys, timestamps are provided by a monotonically
increasing \emph{global version  clock (GVC)} managed by a central service. 
CockroachDB instead uses the local clock of
one of the regions (called node therein), which is closely synchronized relative to other regions and furthermore ensures causality.
We use a similar approach for local transactions in \sys.

Upon commit, a transaction obtains a \emph{commit timestamp} $ts_2$, and the items it wrote are persisted with this version.
Snapshot isolation allows the commit timestamp to be later than the tentative timestamp used for reading, 
which TPSs exploit to reduce conflicts.

During a transaction, write calls indicate their intents to write; this is done using
a dedicated column (part of the value in our data model).
A write intent can take the form of a semantic lock on the key, blocking read attempts (as in Percolator) or
an indication that the write is uncommitted and hence can be safely ignored (as in Omid). 
% which keeps logical (application-level) locks in some implementations (Percolator) and tentative
% updates in others (e.g., the new version of Omid~\cite{omid-blog}, and CockroachDB). 
While write intents differ across implementations, we assume that the following generic boolean function is  provided:
\begin{description}
\item[\code{hasWriteIntent(key, version)}] returns true if the specified version of key has a write intent indication; if version is not provided, the 
latest version associated with key is checked.
\end{description}

\remove{
Note: in certain implementations (like the virtual lock per-key used in Percolator), the write-intent of all versions associated 
with the same key is the same, whereas in other cases (like Omid, which uses tentative versions), a
new version may have a write intent while an older one does not.
}

In more detail, a transaction goes through the following phases (outlined in Algorithm~\ref{alg:schema}):
\begin{enumerate}
  \item \emph{Begin} -- 
  When a transaction begins, it obtains a tentative timestamp (version) $ts_1$ for reading its consistent snapshot, and unique transaction id.
  The two can be combined (i.e., $ts_1$ can serve as the  transaction id, provided that it is unique).
  In most cases, this is done using a centralized entity (sometimes called timestamp oracle~\cite{Percolator2010,OmidICDE2014}
   or transaction manager~\cite{omid-blog}). 
  In CockroachDB, the timestamp is based on a local clock that is ``close to'' real-time and preserves causality 
  across regions, and unique transaction ids are used to break ties in case timestamps (from different regions) are identical. 

  \item \emph{Transactional reads and writes} -- 
  %: Collect reads and indicate write intents -- 
 In the course of a transaction, reads  obtain a consistent snapshot,
 %\emph{collect} values for their transaction's snapshot, 
 while write operations indicate their \emph{intent} to write. 
 %\Idit{We said that it was possible to do write intents at commit time rather than encounter time, 
 %but do we have any example of a system that does it? I think not, hence removed this.
 % Only warp does but it's different as it's not SI, not multi-versioned.}
  	 	\begin{itemize}
  		\item  \emph{A read operation} obtains the value of a single object atomically. 
  		Only versions committed with timestamps  smaller or equal to the transaction's $ts_1$ are read. 
 		Different  policies are used for resolving pending write intents. For example, Omid 1 resolves them 
 		using data on all past commits that the client obtains at begin time, whereas CockroachDB and Omid 2 
 		have the read refer to a centralized transaction table (also called commit table). 
		Percolator  waits for the intent to be lifted (by the completion of the writing transactions), and in case the wait times-out, 
		forces this tranaction to abort. 
	 	 CockroachDB forces the transaction with the write intent to either commit with a higher version 
  		than its own read timestamp, or abort. Similarly, the solution we implement in \sys\ forces the transaction with the pending write 
  		intent to abort. 
  		\item \emph{Indicating write intents} changes the objects' write intent columns
  		to indicate a transaction attempting to write them is under way. The value the
  		transaction intends to write is added with a new version, typically the transaction's $ts_1$.
% In Omid, this   		version is the transaction's id. 
		Each object is updated atomically by itself. 
		In some solutions writes check for conflicts before declaring their intents~\cite{cockroach}, whereas in others, 
		all conflict detection is deferred to commit time. 
  %This can occur either at encounter time or at commit time, in which case it occurs as the first phase of the commit. 
  	\end{itemize}
  \item \emph{Obtain commit timestamp} --
  When a transaction is ready to commit, it gets a commit timestamp, $ts_2$. 
  In most cases, e.g.,~\cite{Percolator2010,tephra,OmidICDE2014,omid-blog}, 
  this is the GVC value at commit time. 
   \item \emph{Validation/conflict detection} -- Before a transaction can commit, it must check that it does not conflict with any 
  concurrent transactions.  For SI, we need to check for write-write conflicts only. 
  This step checks write intentions as well as version numbers. It may be combined  with the above step using a centralized 
  transaction manager~\cite{OmidICDE2014,tephra,omid-blog}, or may rely a two-phase commit protocol where the written objects are first 
  locked, then validated, and then committed~\cite{Percolator2010}. 
 Alternatively, conflicts may be detected in situ by atomically validating each written object as part of adding a write  intent~\cite{cockroach}.
  \item \emph{Indicate commit} --  In case validation succeeds, the transaction is committed 
  in one atomic irrevocable  step. This is achieved by writing to a designated persistent \emph{commit entry}, 
  which can reside in a global table (like the commit table of 
  Omid 2 and the transaction table of CockroachDB) or alongside the first  key written by 
  the transaction (as in Percolator and \sys).  Note that a commit attempt may fail and abort instead. 
  \item \emph{Clean-up} -- Finally, a tranaction changes its write intents to
  persistent writes in case of commit, and removes them in case of abort. This
  phase occurs after the transaction is persistently committed or aborted via the commit entry, in
  order to reduce the overhead of future transactions (by sparing them the need to check the commit entry)
  and to garbage collect   obsolete information. 
  \remove{Note that whenever a transaction encounters a write
  indication in the collect phase it must access the commit entry in order to
  check the transaction's commit status. Once the clean-up phase is over, future
  transactions no longer incur this overhead for keys updated by the terminated
  transaction.}
\end{enumerate}

 