\subsection{\sysll\ algorithm} 
\label{ssec:ll}

\begin{figure}[!t]
  \centering
  
  \begin{subfigure}[tb]{\columnwidth}
      \centering\small
      
      
      \begin{tabular}{|c|c|c|c| c| c | c|}
\multicolumn{4}{c}{Data Table}&  \multicolumn{3}{r}{\hspace{1mm} Commit Table}\\
\cline{1-4} \cline{6-7}
key & value & version & commit & & $ts_r$ & $ts_c$ \\
\cline{1-4} \cline{6-7}
$k_1$ & a & 3 & nil & &  &  \\
\cline{6-7} \cline{1-4}
\end{tabular}
    
	\caption[]{Pending transaction}
    \label{fig:model:tentative}
  \end{subfigure}
  
  \begin{subfigure}[t]{\columnwidth}
    \centering\small
    
          \begin{tabular}{|c|c|c|c| c| c | c|}
\multicolumn{4}{c}{Data Table}&  \multicolumn{3}{r}{\hspace{1mm} Commit Table}\\
\cline{1-4} \cline{6-7}
key & value & version & commit & & $ts_r$ & $ts_c$ \\
\cline{1-4} \cline{6-7}
$k_1$ & a & 3 & nil & & 3 & 7 \\
\cline{6-7} \cline{1-4}
\end{tabular}
    	\caption[]{Committed transaction}
    \label{fig:model:committed}
  \end{subfigure}


  \begin{subfigure}[tb]{\columnwidth}
    \centering\small
          \begin{tabular}{|c|c|c|c| c| c | c|}
\multicolumn{4}{c}{Data Table}&  \multicolumn{3}{r}{\hspace{1mm} Commit Table}\\
\cline{1-4} \cline{6-7}
key & value & version & commit & & $ts_r$ & $ts_c$ \\
\cline{1-4} \cline{6-7}
$k_1$ & a & 3 & 7& & 3 & 7 \\
\cline{6-7}
%$k_2$ & b & 3 & nil \\
\cline{1-4}
\end{tabular}
	\caption[]{Post-committed transaction}
    \label{fig:model:postcommit}
  \end{subfigure}

  
  \caption{Evolution of \sysll\ metadata during a transaction. The transaction receives $ts_r=3$ in the begin stage 
  and uses this as the version number for tentative writes. It receives a commit timestamp $ts_c=7$ when committing.}
  \label{fig:model}
\end{figure}



\begin{algorithm}[htb]
\begin{algorithmic}[1]
%\small
\Procedure{begin}{}
\State checkRenew()
\State return Clock.fetchAndIncrement()
\EndProcedure
\Statex
\Procedure{commit}{$txid$, write-set}
\State checkRenew()
\State $ts_c \leftarrow$ Clock.fetchAndIncrement()
\If{conflictDetect($txid$, write-set, $ts_c$) } 
 \State return $ts_c$
 \Else
 \State return {\sc abort}
\EndIf
\EndProcedure
\Statex
%
\Procedure{checkRenew}{} \Comment HA support
\If{lease $<$ now + $\delta'$} \label{l:lease-start} \Comment extend lease
 \State renew lease for $\delta$ time \Comment atomic operation
 \If{failed} halt \EndIf 
\EndIf  \label{l:lease-end}
\If{Clock $=$ epoch}  \label{l:epoch-start} \Comment extend epoch
\State epoch $\leftarrow$ Clock +  range
 
\If{$\neg$CAS(maxTS, Clock, epoch) } halt \EndIf 
\EndIf  \label{l:epoch-end}
\EndProcedure

\end{algorithmic}
\caption{\sysll's TM algorithm with HA support.}
\label{alg:ha}
\end{algorithm}

\begin{algorithm}[t]
  \begin{algorithmic}
 %   \small
 \Procedure{begin}{}
       \State  return TM.begin
\EndProcedure
%
  \Procedure{write}{$ts_r$, key, val}
       \State  return ds.put(key, val, $ts_r$, nil)
       \State  track key in write-set 
\EndProcedure
%     
\Procedure{read}{$ts_r$, key} 
      \For{rec $\leftarrow$ ds.get(key, versions down from $ts_r$)}
 			\State $ts_c \leftarrow$ {\sc checkStatus}(rec, $ts_r$)
       			 \If{$ts_c \not=$ abort  $\wedge\ ts_c <  ts_r$}  
 			 	\State return  rec.value 
			\EndIf
      \EndFor
      \State  return nil
      \EndProcedure

\Statex

%      		\Procedure{checkLeader}{\tuple{k, ts}} 
%     			\State leader $\leftarrow$ ds.get(\tuple{k, ts})
%    			 \If{leader $=$ nil} return abort \Comment{leader removed} \EndIf 
%		     	 \If{ leader.commit $\not=$nil} \Comment transaction is complete
%		     	 	\State return leader.commit 
%		     	 \EndIf
%		     	 \Comment try to abort pending transaction 
%			\State ok $\leftarrow$ ds.check\&mutate(leader.commit, nil, abort)
%			\If{$\neg$ok} \Comment leader status has changed -- recheck  
%				\State return  {\sc checkLeader}({leaderPtr}) \EndIf
%			\State return abort
%	   	\EndProcedure

      		\Procedure{checkStatus}{rec, ts} 
	%	     	 \While{true} \Comment at most two iterations 
			\If{rec.commit $\not =$nil}  
     			 \State return rec.commit \EndIf
      				\State $ts_c  \leftarrow$ CT.get(ts) 
      				\If{$ts_c = nil$}  \Comment no CT entry -- set transaction status to $\bot$
      					\State $ts_c \leftarrow$ CT.putIfAbsent(ts, $\bot$) 
      					 \Comment returns new value
				\EndIf
      				
 				 \If{$ts_c = \bot$  }  
 				 	\State \Comment check for race: committed before $\bot$ entry was created
 				 	\If{rec.commit $\not =$nil}  return rec.commit \EndIf
 				 	\State return abort 				
				\EndIf

%
 %    				 \If{$ts_c =$ nil}  \Comment{abort transaction}  
     				% 	\State ok $\leftarrow$ CT.putIfAbsent(ts, abort)
%					\If{CT.putIfAbsent(ts, abort)}
%						\State return abort	
%					\Else \Comment entry no longer nil, retry
%						\State return {\sc checkStatus}(ts)
%	     				 \EndIf 			
%				\EndIf
%				return abort
%				\Else
%					\State return rec.commit  %\Comment transaction is complete 
%					\State return leader.commit \Comment transaction is complete
%				\EndIf 		     	 	
%		     	 \EndWhile
	   	\EndProcedure
\Statex

\Procedure{commit}{$ts_r$, write-set}
      	\remove{\State ds.flush}
      	\State $ts_c \leftarrow$ TM.commit($ts_r$, write-set) \Comment may return abort
      	\If{$ts_c \not=$ abort}
	      	\If {CT.putIfAbsent($ts_r$, $ts_c$) $=\bot$}
%   		\If{$\neg$ok} 
   		 	\State $ts_c \leftarrow$ abort 
   		 \EndIf
	\EndIf
	\State \Comment post-commit
	\ForAll{keys k $\in$ write-set}
			\If{$ts_c =$ abort} ds.remove(k, $ts_r$)  	
%			\Else\ update  commit field of \tuple{k, $ts_r$} to $ts_c$  in ds%  $\leftarrow ts_c$ 
			\Else\ ds.update(k, $ts_r$, commit, $ts_c$)
			\EndIf
	\EndFor
\EndProcedure
      
  \end{algorithmic}
  \caption{\sysll's client-side operations.} 
  %for transaction with read timestamp $ts_r$.}
  \label{fig:get-pseudocode}
\end{algorithm} 

Like Omid, \sysll\ uses a dedicated \emph{commit table (CT)} for storing commit entries.
A transaction is atomically committed by adding to the CT a commit entry mapping its $ts_r$ to its $ts_c$.
The post-commit phase then copies this information to 
a dedicated \emph{commit} column in the data table, in order to spare future reading transactions
 the overhead of checking the commit table. 
 Figure~\ref{fig:model} shows the metadata of a transaction during its stages of execution. 

Whereas Omid's CT is updated by the TM, \sysll\ distributes the CT updates amongst the clients.
Its TM is thus a simplified version of Omid's TM, and appears  in Algorithm~\ref{alg:ha}. It has two roles:
First, it allocates begin and commit timestamps by fetching-and-incrementing a monotonically increasing global clock.
Second, upon commit, it calls the \emph{conflictDetect} function, which 
performs validation (i.e., conflict detection) using an in-memory hash table
by checking, for each key in the write-set, that its commit timestamp in the hash-table is smaller than the 
committing transaction's $ts_r$. If there are no conflicts, it 
updates the hash table with the write-set of the new transaction and its $ts_c$. 
%(For more details see~\cite{Omid2017}).
The  \emph{checkRenew} procedure supports the TM's  high availability, and is explained at the end of this section.



\noindent
Client operations proceed as follows (cf.~Algorithm~\ref{fig:get-pseudocode}):

\mypara{Begin.}
The client sends a begin request to the TM, which assigns it a read timestamp $ts_r$.

\mypara{Write.}
The client uses the data store's update API to add a tentative record to the data store, with the written key and value, 
version number $ts_r$, and nil in the commit column.
It also tracks key in its local write-set.

\mypara{Read.}
The algorithm traverses data  records (using the data store's ds.get API) pertaining
to the requested key with a version that does not exceed $ts_r$, latest to earliest, and returns the first value that is committed
with a  version smaller than or equal to $ts_r$. Upon
encountering a tentative record (with commit=nil), the algorithm calls the {\sc checkStatus} function, which
gets the leader's $ts_c$ from the data store, and again returns the key if that $ts_c$ is smaller than $ts_r$. 

If the leader's commit entry is still nil, read cannot return without determining the final commit timestamp
of the pending transaction. 
%\Yoni{example here?}. 
To this end, {\sc checkStatus} attempts to forcefully abort the pending transaction. This is done using the
 {check\&mutate} operation, which atomically reads and sets the commit entry to abort in case its value is still nil. 
Before calling {check\&mutate}, it is possible to wait a configurable amount of time in order to let the transaction complete without aborting it.
If check\&mutate fails, this means that the transaction is no longer pending, and {\sc checkStatus} is recursively called to
re-read the leader's entry. Note that during the nested call, the commit status can no longer be nil, and so it
always returns without attempting another check\&mutate.
 
%When a transaction commits, it atomically checks it hasn't been invalidated before inserting the $ts_c$ to the commit .


\mypara{Commit.}
The client first 
\remove{flushes all its writes to the data store and then} 
sends a commit request to the TM. 
If the TM detects conflicts then the transaction aborts, and otherwise the TM provides the transaction with its commit  timestamp $ts_c$. 
\remove{Flushing before calling the TM ensures that transactions with read timestamps exceeding $ts_c$ 
will find the committing transaction's records in the data store.}
The client then proceeds to commit the transaction, provided that no read has invalidated it. To ensure the latter, the client uses 
the data store's check\&mutate function to write $ts_c$ to the leader's commit column 
only if the commit status is still nil.

To avoid an extra read of the leader on every transactional read, once a transaction is committed, the post-commit stage writes 
the transaction's $ts_c$ to the commit columns of all keys in  the transaction's write-set. 
%Following a successful commit, the client adds $ts_c$ to all data items it wrote to.

\mypara{High availability.} The TM is implemented as a primary-backup process pair to ensure its high availability. 
The backup detects the primary's failure using timeouts. When it detects a failure, it immediately begins serving new
transactions, without any recovery procedure. Because the backup may falsely suspect the primary because of
unexpected network or processing delays (e.g., garbage collection stalls), we take precautions to avoid correctness
violations in (rare) cases when both primaries are active at the same time.

To this end, we maintain two shared objects, managed in Apache Zookeeper and accessed infrequently.
The first is \emph{maxTS}, which is the maximum timestamp an active TM is allowed to return to its clients.
An active (primary) TM periodically allocates a new \emph{epoch} of timestamps that it may return to clients by atomically
increasing maxTS (using a compare-and-swap (CAS) operation).  
Following failover, the new primary  allocates a new epoch for itself, and thus all the timestamps it returns to clients
exceed those returned by previous primary. 
The second is a locally-checkable \emph{lease}, which is essentially a  limited-time lock. 
As with locks, at most one TM may hold the lease at a given time (this requires the TMs' clocks to advance roughly at the same rate). 
This ensures that no client will be able to commit a transaction in an old epoch after the new TM has started 
using a new one.



