\begin{figure}[!t]
  \centering
  
  \begin{subfigure}[t]{\columnwidth}
      \centering
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      key & value & version & commit& leader\\
      \hline
      \hline
      k1 & a & 3 & &\\
      \hline
      k2 & b & 3 & &k1\\
      \hline
      k2 & c & 3 & &k1\\
      \hline
    \end{tabular}
	\caption[]{Tentative transaction}
    \label{fig:model:tentative}
  \end{subfigure}
  
  \begin{subfigure}[t]{\columnwidth}
    \centering
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      key & value & version & commit& leader\\
      \hline
      \hline
      k1 & a & 3 & 7&\\
      \hline
      k2 & b & 3 & &k1\\
      \hline
      k2 & c & 3 & &k1\\
      \hline
    \end{tabular}
	\caption[]{Committed transaction}
    \label{fig:model:committed}
  \end{subfigure}


  \begin{subfigure}[t]{\columnwidth}
    \centering
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      key & value & version & commit& leader\\
      \hline
      \hline
      k1 & a & 3 & 7&\\
      \hline
      k2 & b & 3 & 7&\\
      \hline
      k2 & c & 3 & 7&\\
      \hline
    \end{tabular}
	\caption[]{Post-committed transaction}
    \label{fig:model:postcommit}
  \end{subfigure}

  
  \caption{Different stages of metadata during a transaction. The $txid$ the transaction received from the begin stage is 3, and the $ts_c$ it received when committing is 7. The leader chosen for this transaction is k1 }
  \label{fig:model}
\end{figure}


\begin{algorithm}[t]
  \begin{algorithmic}
    \begin{small}
      \Procedure{get(key)}{} 
      \For{rec $\leftarrow$ ds.get(\emph{key}, versions down from $ts_r$)}
      \If{rec.commit$\not=$nil} \Comment not tentative
      \If{rec.commit $< ts_r$}  \State return rec.value \EndIf
      \Else \Comment tentative
      \State value $\leftarrow$ {\sc GetTentativeValue(rec)}
      \If{value $\not=$nil}  
	  \State return value
      \EndIf
      \EndIf
      \EndFor
      \EndProcedure
      \Statex
      \Procedure{GetTentativeValue(rec)}{} 
      \State leader $\leftarrow$ rec.leader
      \State $tx_c$ $\leftarrow$ checkAndInvalidate(leader)
      \If{$tx_c$ $\not=$ nil} \Comment  committed
      \State update rec.commit \Comment helping 
      \If{$tx_c$ $< ts_r$}  return rec.value \EndIf
      \Else

      \State  return nil
      \EndIf
      \EndProcedure
    \end{small}
  \end{algorithmic}
  \caption{\sys's \emph{get(key)} operation.} 
  %for transaction with read timestamp $ts_r$.}
  \label{fig:get-pseudocode}
\end{algorithm} 



\Yoni{ explain here or in \ref{sec:ll-txns} that each key has multiple versions, we use $txd$ $tx_r$ $tx_c$....}

\subsection{Transaction metadata}
\label{ssec:tso}
\Yoni{make sure Idit defines  in section \ref{sec:ll-txns}}
Figure~\ref{fig:model} shows the metadata of a transaction during its stages of execution. For each version of a key in the data store we add 3 additional fields: (1) A \emph{version} field, which holds the $txid$ of the transaction that wrote it, in our implementation the $tx_r$ received at the begin stage is used as the $txid$. (2) A \emph{commit} field, which indicates whether the data is tentative or committed, if it's committed, the value will be the transaction's $ts_c$. (3) A \emph{leader} field. Since the transaction commit needs to be an atomic step, one key from the transaction's write set is chosen to be the \emph{leader} of that transaction, and when the transaction is committed a single atomic write is initiated to the \emph{leader's} commit field with the transaction's $ts_c$. Transaction read operations refer to the key's \emph{leader} to find out whether the value has been committed or not.




\subsection{Client-side operation}
\label{ssec:client}

\paragraph{Begin}
The client obtains from the TSO a read timestamp $ts_r$, which also becomes its transaction id ($txid$).


\paragraph{Get}
Algorithm~\ref{fig:get-pseudocode} describes \sys's implementation of Algorithm~\ref{alg:schema} READ procedure.
The data store's get operation is referred to as ds.get(key,version). The algorithm traverses records pertaining
to key with versions smaller than $ts_r$, latest to earliest, and returns the first key that is committed. Upon
encountering a tentative record (with commit=nil), the algorithm will get the leader's record from the data store,
read its $ts_c$ from the \emph{commit} field and return the key if the $ts_c$ is smaller than $ts_r$. To ensure SI,
if the leader's \emph{commit} field is nil, the transaction that leader represents must be aborted \Yoni{example here?}. The checkAndInvalidate function will atomically read the \emph{commit} field and if its value is nil, will insert an invalidation symbol in it. When a transaction commits, it atomically checks it hasn't been invalidated before inserting the $ts_c$ to the \emph{commit} field.

\paragraph{Put}
The client adds the tentative record \emph{(key, value, txid, nil,leader)} to the data store.
The leader is chosen to be the first key the client updates during a transaction.
To ensure monotonicity of written versions as seen in Section~\ref{ssec:regular-client-alg}, instead of using the standard \emph{put} operation the data store exposes, we must use checkAndMutate which will atomically put the record only if the latest version of the key is smaller than $ts_r$.


\paragraph{Commit}
The client requests \emph{commit(txid, write-set)} from the TSO. The TSO assigns it a commit timestamp $ts_c$ and checks for conflicts. If there are none, the client will write the $ts_c$ in the leader's \emph{commit} field. As explained at the Get stage, the transaction must atomically commit only if no other get invalidated it. This is done using the data store checkAndMutate function to read the invalidation symbol before writing the $ts_c$.
To avoid an extra RPC to the leader on every read, after a transaction is committed, a post-commit stage writes the $ts_c$ to the \emph{commit} field of every key in the write set of that transaction. 
Following a successful commit, the client adds $ts_c$ to all data items it wrote to.

\paragraph{Singleton Read}
\Yoni{This is the same as \ref{ssec:local-client-alg}}
\paragraph{Singleton Write}


\Yoni{what about WC and BRWC?}

\subsection{HBase region server}
\label{ssec:hbase}
\Yoni{Aran, is there something special to say here?}
