
We consider a TPS  that spans multiple regions (sometimes called nodes, domains, or shards) and supports global
(multi-region) transactions. Data is stored in an underlying NOSQL key-value store, 
such as HBase~\cite{hbase}, BigTable~\cite{bigtable-osdi06},  or
RocksDB~\cite{rocksdb}. Clients access the data store directly using the TPS API, and partake in transaction
coordination, possibly using the assistance of a  centralized service.

We first describe the data model and API of the underlying data store (Section~\ref{ssec:data-model}).
We then proceed to define  the transaction semantics provided by the TPS (Section~\ref{ssec:transactions}). 

\subsection{Data store}
\label{ssec:data-model}

The underlying data store holds  \emph{objects} (often referred to as \emph{rows}) identified by unique \emph{keys}.
We consider multi-versioned objects, where object values are associated with \emph{version numbers}, and
multiple versions associated with the same key may co-exist in the data store.
Thus, at any given time, an object holds a tuple \tuple{key,\tuple{version,value}+}, where value
can be structured to consist of multiple columns.
We further assume that a write operation can specify the version number it writes to.
%monotonically increasing ??
%\paragraph{API} 
The underlying data store provides the following API:
\begin{description}
\item [\code{\tuple{version,value} read(key)}] -- atomically returns the value with
the highest version associated with key along with its version.
\item The API further allows traversing (reading) earlier versions of the same
key in descending order.
\item [\code{write(key,value,version)}] -- atomically creates or updates the version:
\remove{If the provided version number is smaller than the key's latest stored version, the update fails.} 
if the version already exists, its value is updated;
otherwise, a new version is added. Garbage collection of obsolete versions is a separate
process.
\item [Read-modify-write] --  data stores often provide means to atomically read and
update an object, (e.g., HBase exports CheckAndMutate operations, which are 
internally implemented using a RW lock, whereas BigTable supports row transactions). We
will extend this capability below in order to implement certain atomic
operations at the data store level.
\end{description}

\subsection{Transaction semantics} \label{ssec:transactions}

A \emph{transaction} is a sequence of read and write operations on different objects that ensures the so-called ACID properties:
\emph{atomicity} (all-or-nothing execution), \emph{consistency} (preserving each object's semantics), 
\emph{isolation} (in that concurrent transactions do not see each other's partial updates), and 
\emph{durability} (whereby updates survive crashes).

Different isolation levels can be considered for the third property. We consider systems providing  
snapshot isolation~\cite{DBLP:conf/sigmod/BerensonBGMOO95}, 
which is provided by popular database technologies such as Oracle, PostgreSQL, and SQL Server.

Intuitively, SI ensures that the information a transaction retrieves from the database 
does not mix old and new values. For example, if a task updates the values of two stocks, then no other transaction may observe the old value of one of these stocks and the new value of the other. 
%
More precisely, SI enforces a total order on committed transactions according to their commit times so that 
\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{2pt}  
\item
each transaction's read operations see a consistent snapshot of the database reflecting write operations by
 exactly those transactions that committed prior to the transaction's start time; and 
\item
 a transaction commits only if none of the items it updates has been modified since that snapshot.
 \end{enumerate}
Thus, under SI, two concurrent transactions conflict only if they both \emph{update} the same item.  
In contrast, under serializability, a transaction that updates an item also conflicts with transactions that \emph{read} that item. Snapshot isolation is thus amenable to implementations (using multi-versioned concurrency control) that 
allow more concurrency than serializable ones, and hence scale better.

TPSs allow programmers to  delineate transactions via the begin and commit APIs: 
the sequence of read and write operations a client invokes between begin and  commit pertains to one transaction.
Following a commit call, the transaction may successfully \emph{commit}, whereby all of its operations take effect;
in case of conflicts, (i.e., when two concurrent transactions attempt to update the same item), the transaction may
\emph{abort}, in which case none of its changes take effect. An abort may also be initiated by the programmer, e.g., 
on encountering an error. Applications typically retry a transaction upon (either type of) abort. 


The data is \emph{partitioned} (or sharded), and each object belongs to one region. 
Global transactions may span multiple regions, and atomically commit or abort on all. 
%%%\emph{Local transactions} are ones that access a single region.
