

We now describe \sys, a scalable low-latency TPS.
% on top of HBase. 
\sys\ is an evolution of the open-source Omid TPS, redesigned to reduce latency.
We begin in Section~\ref{ssec:schema} with some background on the modus operandi of existing TPSs that support SI, including Omid. 
We will see that, while many TPSs follow a similar schema,  they make different design choices when implementing this schema. 
We discuss the design choices of \sys\ in Section~\ref{ssec:ll-txns}. 
We then proceed to give a detailed description of the \sys\ protocol
in Section~\ref{ssec:ll}.

\subsection{Background: Schema of TPS operation}
\label{ssec:schema}


In many TPSs, transaction processing follows the following general schema, outlined in Algorithm~\ref{alg:schema}, 
while systems vary in their implementations of each of the steps:

\remove{
For example, whereas most systems rely on a centralized service for timestamp allocation~\cite{OmidICDE2014,omid-fast,tephra,Percolator2010}, this is not essential~\cite{cockroach}; similarly, validation (conflict detection) can use a centralized service~\cite{OmidICDE2014,omid-fast,tephra}, per-transaction entries in a global table~\cite{cockroach}, or distributed locking and validation~\cite{Percolator2010}. 
Different ways to implement this schema are  discussed in Section~\ref{sec:context}.
We now overview the phases a transaction goes through, focusing on Omid's approach.
}

\begin{algorithm}[tb]
\begin{algorithmic}[1]
\Procedure{begin}{}
\State obtain read timestamp $ts_r$ 
\EndProcedure
\Statex

\Procedure{write}{key, value} \Comment transactional write
\State optionally check for conflicts and abort if found 
\State indicate write intent for key with value and $ts_r$
\State add key to local write-set
\EndProcedure
\Statex

\Procedure{read}{key} \Comment transactional read
\If{hasWriteIntent(key)}
	\State resolve, possibly  aborting transactions \label{l:resolve}
\EndIf
\State return highest version   $\le ts_r$ of key
\EndProcedure

\Statex

\Procedure{commit}{write-set}
\State obtain commit timestamp $ts_c$
\Statex \Comment check for write-write conflicts  \label{l:validate}
\If{validate(write-set, $ts_c$)}  
	\Statex \Comment commit all write intents with version $ts_c$
	\State atomically and persistently indicate commit   \label{l:commit}
\Else
	\State abort	
\EndIf
\State post-commit: update meta-data
\EndProcedure

\end{algorithmic}
\caption{TPS operation schema.} 
\label{alg:schema}
\end{algorithm} 


\paragraph{Begin.} 
  When a transaction begins, it obtains a read timestamp (version) $ts_r$ for reading its consistent snapshot.
  %, and unique transaction id.   The two can be combined (i.e., $ts_r$ can serve as the  transaction id, provided that it is unique).
 In most cases, this is done using a centralized \emph{transaction manager (TM)}, sometimes called timestamp 
 oracle~\cite{Percolator2010,OmidICDE2014}. 
%  In CockroachDB, the timestamp is based on a local clock that is ``close to'' real-time and preserves causality 
 % across regions, and unique transaction ids are used to break ties in case timestamps (from different regions) are identical. 

\paragraph{Transactional writes.} 
 During a transaction, a write operation indicates its \emph{intent} to write to a single object a certain new value with a certain version number;
a dedicated \emph{commit} column in the object indicates that the write is tentative.

In Omid, the version is the transaction's $ts_r$, which exceeds all versions written by transactions that committed before the
current transaction began. Note that the version order among concurrent transactions that  attempt to update the same key is immaterial, 
since at least one of these transactions is doomed to abort. 

In some solutions writes check for conflicts before declaring their intents~\cite{cockroach}, whereas in others, 
all conflict detection is deferred to commit time. 

\paragraph{Transactional reads.} 
The reads of a given transaction obtain a consistent snapshot of the data store at logical time (i.e., version) $ts_r$.
Each read operation retrieves the value of a single object associated with the highest timestamp that is 
smaller or equal to the transaction's $ts_r$. 

On encountering a write intent, read cannot proceed without determining whether the tentative write should be included in its snapshot,
for which it must know the writing transaction's commit status. 
To this end, TPSs keep per-transaction \emph{commit entries}, which are the source of truth regarding the transaction status 
(pending, committed, or aborted). 
This entry is updated in line~\ref{l:commit} of Algorithm~\ref{alg:schema} as we explain below, 
and is checked in order to resolve write intents in line~\ref{l:resolve}.
In some cases~\cite{Percolator2010,cockroach}, when the writing transaction status is undetermined, the read may forcefully abort
it by updating the commit entry accordingly.

%Similarly, the solution we implement in \sys\ forces the transaction with the pending write intent to abort. 

  \paragraph{Commit.} 
  Commit occurs in four steps:
  \begin{enumerate}
  \item
  Obtain a commit timestamp, $ts_c$. 
  In most cases, e.g.,~\cite{Percolator2010,tephra,OmidICDE2014,omid-fast}, 
  this is the value of some global clock maintained by a centralized entity. 
  \item \emph{Validate} that the transaction does not conflict with any concurrent transaction that has committed since it 
had begun.  For SI, we need to check for write-write conflicts only. 
Validation can be centralized~\cite{OmidICDE2014,tephra,omid-fast} or distributed~\cite{Percolator2010,cockroach}. 

\item \emph{Commit} or abort in one  irrevocable atomic step. This is achieved by persistently writing to the \emph{commit entry}, 
  which can reside in a global table~\cite{omid-fast,cockroach} or alongside the first  key written by 
  the transaction~\cite{Percolator2010}.  
  
 \item \emph{Post-commit}: 
  Finally, a transaction changes its write intents to
  persistent writes in case of commit, and removes them in case of abort. This
  occurs after the transaction is persistently committed or aborted via the commit entry, 
  and can be done asynchronously.
  %in
  %order to reduce the overhead of future transactions (by sparing them the need to check the commit entry)
  %and to garbage collect   obsolete information. 
 \end{enumerate}
 
  \remove{Note that whenever a transaction encounters a write
  indication in the collect phase it must access the commit entry in order to
  check the transaction's commit status. Once the post-commit phase is over, future
  transactions no longer incur this overhead for keys updated by the terminated
  transaction.}

\subsection{\sys\ design choices}
\label{ssec:ll-txns}

We now discuss our design choices, which are summarized and compared with other TPSs in  Table~\ref{table:design-space}. 

\begin{table*}[htb]

\centerline{
\begin{tabular}{|l|ccccc|}
\hline
 & 
 \multicolumn{2}{c}{		 validation} & 
  \multicolumn{2}{c}{commit  entry}	& 
 resolving write intents\\
TPS	
& 	
scheme & time & 
location& update & 	
on read may cause abort	\\
\hline
Percolator 	& {\bf D} & commit & {\bf D} & {\bf D} & yes \\
Omid1, Tephra 	& {\bf C} & commit & {\bf R} & {\bf C} & no\\
Omid  		& {\bf C} & commit & {\bf C} & {\bf C} & no\\
CockroachDB	& {\bf D} & write     & {\bf C} & {\bf D} & yes\\
\sys			& {\bf C} & commit & {\bf D} & {\bf D} & yes\\
\hline
\end{tabular}
}
\caption{Design choices  in TPSs. {\bf C} -- centralized,  {\bf D} -- distributed, {\bf R} -- replicated.}
\label{table:design-space}
\end{table*}


\paragraph{Centralized validation.}
Percolator, the first TPS in this vein, uses a distributed commit protocol that locks all written objects during validation. 
Unfortunately, while an object is locked, other transactions attempting to access it are blocked.
Since clients may stall or fail while holding a lock, Percolator times-out on unresponsive clients and aborts transactions on their behalf. 
To eliminate the need for such recovery, newer systems preferred to rely on 
a centralized TM for validation~\cite{OmidICDE2014,tephra,omid-fast}.
CockroachDB takes a different approach of performing distributed validation at write time, by replacing writes with atomic validate-and-write operations that can abort either the current transaction or a conflicting one. 
Since the approach of CockroachDB slows down transactional writes, and since Omid's centralized conflict detection is extremely scalable, 
(capable of sustaining orders of magnitude higher throughput than the network~\cite{omid-fast}), 
\sys\ adopts this mechanism from Omid. 

\paragraph{Distributed commit entry.}
Omid 1 and Tephra replicate all commit entries among all active clients, which consumes high bandwidth and does not scale. Omid and 
CockroachDB instead use dedicated tables. CockroachDB updates the table in a distributed manner, while Omid has the centralized 
TM persist all commits. 
Our experiments show that the centralized access to commit entries is Omid's principal scalability bottleneck, and while this bottleneck is mitigated via batching commit table updates, this also increases latency.
Omid chose this  option as it was designed primarily for high throughput. Here, on the other hand, we target  low latency. 

We therefore opt to follow the design of Percolator, which stores each transaction's commit entry alongside its first written key,
which we call the \emph{leader}, and stores pointers to this leader at all other keys written by the transaction. 
Thus, updates of transaction entries can be performed in parallel by 
independent clients, and such updates are no longer a performance bottleneck. 
We will see below that this modification improves performance 
\inred{by up to an order of magnitude} on small transactions.

\paragraph{Write intent resolution.}
As in other TPSs, write intents are resolved via the commit entry.
If the transaction status is committed, the written value is taken into account, and if it is aborted, the value is ignored. 
If the transaction status is pending, the reader  forces the writing transaction to abort by using 
an atomic checkAndMutate operation to set its status to aborted. Similar scenarios occur in Percolator and CockroachDB, since 
they update commit entries in a distributed manner. Omid and Tephra, on the other hand, do not need to force such aborts, because they use a single  TM for timestamp allocation, validation, and writing the commit entry in a way that ensures that  if the read sees a write intent by an uncommitted transaction, that transaction will not commit with an earlier timestamp than the read.

\remove{

The centralized service, called Transactional Status Oracle (TSO), maintains an in-memory hash table mapping keys to 
commit timestamps ($ts_c$) of transactions that last wrote them. A conflict arises whenever a key in a transaction's write-set has been written 
with a timestamp higher than its $ts_r$. 
In case the conflict detection service crashes, all pending transactions are aborted, and it can be immediately restarted with an empty table, because only conflicts with concurrent transactions need to be checked. 


%
The possibility of reads aborting pending transactions means that commit attempts (line~\ref{l:commit}) have to  
check whether the transaction is aborted atomically with writing the commit status.


\subsection{Local transactions in \sys}
\label{ssec:fp-impl}
To support local transactions, we implemented the algorithms and APIs described in Section~\ref{sec:alg}. Each Hbase region server maintains an LVC which is updated whenever a transaction accesses it. Omid's API was extended to support FP transactions, and the write stage in regular transactions was modified to use checkAndMutate instead of put. 


 }
 